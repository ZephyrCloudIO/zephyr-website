---
title: 'Next.js Without Lock-In: vinext on Zephyr'
slug: 'nextjs-without-lock-in-vinext-on-zephyr'
date: '2026-02-24'
heroImage: '/images/blog/module-federation-vs-native-esm/hero.webp'
listingImage: '/images/blog/module-federation-vs-native-esm/hero.webp'
description: 'Cloudflare vinext and Zephyr Cloud unlock Next.js-style DX with Vite speed, edge-native deployment, and infrastructure portability.'
authors: ['Néstor López']
tags: ['architecture', 'edge', 'deployment', 'module-federation', 'cloud', 'dx']
featured: true
readingTime: 9
---

Something shifted yesterday.

When Cloudflare's Dane Knecht [called it "Next.js Liberation Day,"](https://x.com/dok2001/status/2026386974580330830) he wasn't being dramatic. He was naming what engineering teams have been saying in quieter channels for months: "Help us run Next fast and secure—without the lock-in and the cost."

This isn't just Twitter hype. It's what happens when you hit architectural fatigue. You know the symptoms. You've seen them in your own standups. Teams searching for how to run Next.js without Vercel. Looking for a Vite-based alternative that doesn't sacrifice the API surface they know. Asking whether there's a React stack that actually works with Module Federation without constant bundler rewrites. Wanting infrastructure portability that doesn't come at the cost of developer experience.

The search has been frustrating because the options were binary: stick with the vertically integrated path you know, or rebuild everything from scratch. Until now.

## The One-Sentence Shift

**vinext** gives you the Next.js API surface, powered by Vite, deployable anywhere. Zephyr makes that combination production-ready at the edge.

Together, they separate framework ergonomics from hosting assumptions. That's the structural change that matters.

## What vinext Actually Is

Cloudflare [open-sourced vinext](https://github.com/cloudflare/vinext) yesterday—a clean reimplementation of the Next.js API surface built on top of Vite instead of Turbopack. Not a wrapper. Not an adapter. A from-scratch rebuild of routing, server rendering, React Server Components, server actions, caching, middleware—all of it implemented as Vite plugins.

What this unlocks is familiar: the same `app/` directory structure, the same `pages/` conventions, the same API patterns your team already knows. But underneath, you're getting Vite's build speed, Vite's ecosystem, and Vite's portability. The kind of portability that lets you deploy to Cloudflare Workers with a single command, sure, but also the kind that doesn't assume anything about where you're running.

This matters because Vite isn't just a faster bundler. It's the build tool that powers [Astro](https://astro.build/), [SvelteKit](https://svelte.dev/), [Nuxt](https://nuxt.com/), and [Remix](https://remix.run/). It's the common ground of the modern frontend ecosystem. When you build on Vite, you're building on something that runs everywhere.

## Why Coupling Became the Problem

For years, "production Next.js" has effectively meant "deploy to Vercel." And let's be clear: that pairing delivered real value. The integration is tight, deployments are fast, the developer experience is polished. Nobody's arguing that it doesn't work.

But tight integration creates tight coupling. Framework changes get tied to platform rollout cycles. Runtime capabilities become gated by infrastructure choices. Architecture decisions get shaped by vendor direction. Cost behavior gets tied to a single provider's pricing model. When you choose Next.js, you're not just choosing a framework—you're choosing a particular hosting path, whether you meant to or not.

Modern engineering teams increasingly want something different. They want infrastructure optionality: the ability to deploy where it makes sense for their workload. They want predictable upgrade paths that aren't contingent on a single platform's roadmap. They want federation compatibility that doesn't break every time the bundler changes. They want long-term architectural control.

vinext makes decoupling feasible. It proves you can have the Next.js API without the Next.js infrastructure assumptions. But having a decoupled framework is only half the solution. You also need a deployment platform that respects that decoupling. That's where Zephyr comes in.

## From Local Dev to Global Edge in Under a Second

We paired vinext with [Zephyr's Vite plugin](https://github.com/ZephyrCloudIO/zephyr-packages/tree/main/libs/zephyr-rspack-plugin) and shipped a live demo to prove this isn't theoretical.

Here's the actual workflow: install `vite-plugin-vinext-zephyr`, add `withZephyr()` to your `vite.config.js`, then build and deploy. That's the whole thing. No CI/CD pipeline to configure. No custom edge worker scaffolding to write. No environment-specific rewrites to maintain. No platform-specific build outputs to wrestle with.

The result: local build to global edge deployment in under one second. Not "fast for a complex process." Actually fast. The kind of fast where you make a change, hit save, and it's live globally before you can switch browser tabs.

[See it running here](https://vinext-vinext-hackernews-zephyr-packages-zephyrcloudio-ze.zephyrcloudapp.dev/). This is a real vinext app, built with Vite, deployed through Zephyr, running on the edge. Not a synthetic benchmark. Not a staged demo. Just the actual developer experience.

Hacker News vinext app deployment on Zephyr:

<TwitterEmbed mediaMaxWidth={560}>
  <p lang="en" dir="ltr">
    And you can deploy it the fastest using{' '}
    <a href="https://twitter.com/ZephyrCloudIO?ref_src=twsrc%5Etfw">@ZephyrCloudIO</a>{' '}
    <a href="https://t.co/O9bfsQqYHY">https://t.co/O9bfsQqYHY</a>{' '}
    <a href="https://t.co/1rvfI47aLb">pic.twitter.com/1rvfI47aLb</a>
  </p>
  {'—'} Néstor (@nstlopez){' '}
  <a href="https://twitter.com/nstlopez/status/2026406859226087704?ref_src=twsrc%5Etfw">February 24, 2026</a>
</TwitterEmbed>

`npx with-zephyr` in action:

<TwitterEmbed mediaMaxWidth={560}>
  <p lang="en" dir="ltr">
    You can now deploy vinext with just one command.
    <br />
    <br />
    npx with-zephyr <a href="https://t.co/HbbaJ4OyHQ">pic.twitter.com/HbbaJ4OyHQ</a>
  </p>
  {'—'} Néstor (@nstlopez){' '}
  <a href="https://twitter.com/nstlopez/status/2026435762686681182?ref_src=twsrc%5Etfw">February 24, 2026</a>
</TwitterEmbed>

## What Zephyr Adds Beyond vinext

vinext enables framework decoupling. Zephyr enables deployment control. They're solving different problems, and they work better together.

Zephyr Cloud provides the orchestration layer that makes vinext practical at scale: global edge deployment orchestration that doesn't require you to think about regions or replication, [Module Federation](https://module-federation.io/)-ready runtime support for teams running microfrontends, a portable infrastructure model that doesn't lock you into a specific cloud provider, and near-instant deployment propagation that makes the iteration loop actually enjoyable.

The key insight here is that infrastructure portability isn't just about being able to switch clouds. It's about being able to think about your application architecture independently of your deployment platform. When the framework and the infrastructure are truly decoupled, you can optimize each for what it's good at. The framework can focus on developer experience. The platform can focus on deployment velocity and global performance. Neither has to compromise for the other.

**How this actually works:** Zephyr uses Cloudflare's [Worker Loaders API](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/) to create isolated V8 isolates for each application version. This isn't just running your code on Workers—it's dynamically loading your entire app as a separate worker with its own compatibility flags, nodejs support, and module resolution. For teams who need self-hosted options, Zephyr also provides Kubernetes workers with Redis/S3-backed storage and multi-region peer-to-peer replication.

**Edge propagation happens fast.** Like, sub-2-seconds fast. Cloudflare KV is eventually consistent, so Zephyr implements exponential backoff retries (0, 2, 5, 15, 30, 60, 120 seconds) to handle the propagation window. In practice, most deployments are globally visible within a couple of seconds.

**Caching is multi-tier and context-aware.** Mutable assets like `remoteEntry.js` and `zephyr-manifest.json` use `max-age=0, must-revalidate` to ensure fresh federation manifests. Immutable hashed assets get 24-hour stale-while-revalidate caching. Application configs cache for 60 seconds client-side. Everything uses ETag-based conditional requests (RFC 7232), so repeated fetches are essentially free when content hasn't changed.

## The Architecture Comparison

Let's be concrete about what changes:

| Stack                     | Build System        | Hosting Coupling | Federation Friendly | Edge Native | Infra Portability |
| ------------------------- | ------------------- | ---------------- | ------------------- | ----------- | ----------------- |
| Next.js + Vercel          | Turbopack / Webpack | High             | Limited             | Yes         | Low               |
| vinext + Cloudflare       | Vite                | Medium           | Moderate            | Yes         | Medium            |
| **vinext + Zephyr Cloud** | **Vite**            | **Low**          | **High**            | **Yes**     | **High**          |

This isn't about replacing one tool with another. It's about restoring architectural leverage. When you can choose your framework and your infrastructure independently, you get back the ability to optimize for your actual constraints instead of the constraints your platform chose for you.

## Performance Is Expected. Control Is Strategic.

Yes, Vite builds are faster than Turbopack. In early benchmarks, vinext builds production apps up to 4x faster and produces client bundles up to 57% smaller. Yes, edge deployment is effectively instant. Yes, the feedback loop feels lighter and more responsive.

But performance is table stakes in 2026. The strategic advantage is control.

Control to deploy anywhere your workload makes sense. Control to scale infrastructure independently of framework upgrades. Control to preserve your architectural intent instead of adapting it to platform limitations. Control to avoid forced migrations when your provider changes direction. Control over cost at scale, so you're not paying a premium for convenience that becomes a tax as you grow.

When framework and infrastructure are truly decoupled, engineering autonomy compounds. You move faster not because your tools are faster, but because your decisions aren't constrained by platform assumptions you never agreed to.

## Who This Is Actually For

This stack is built for teams that want Next.js-style DX without vendor lock-in. Teams that care about infrastructure portability because they've been burned by platform changes before. Teams that run or plan to run Module Federation and need a bundler that won't break their microfrontend architecture. Teams that deploy globally with SSR and need edge-native performance without edge-native complexity. Teams that refuse to freeze their architecture for platform stability.

If you've searched "run Next.js without Vercel" or "Vite-based Next.js alternative" or "edge hosting for Next.js" or "federation-friendly React stack"—you're not alone. Those searches are happening because the ecosystem is moving in this direction. Cloudflare just made it official by validating the Vite-powered Next-style architecture. Zephyr makes it operational at scale.

## The Structural Shift

The React landscape is evolving toward a few clear patterns: Vite-powered build workflows because they're faster and more portable, edge-native runtimes because they make global performance the default, composable frontend systems because teams need to scale development independently, and infrastructure independence because coupling has proven too expensive.

Cloudflare shipping vinext is a strong signal that this direction has industry validation. But having a framework that supports decoupling is only useful if you have a deployment platform that respects it. Zephyr provides that platform.

The era of framework-imposed infrastructure is ending. The frontend is composable again. And composable systems—systems where you can choose the right tool for each job, where you can evolve your architecture without platform permission, where you can optimize for your actual constraints instead of your vendor's business model—those are the systems that win.

**Try it:** [Live demo](https://vinext-vinext-hackernews-zephyr-packages-zephyrcloudio-ze.zephyrcloudapp.dev/) | [vinext on GitHub](https://github.com/cloudflare/vinext) | [Zephyr Cloud](https://zephyr-cloud.io)
